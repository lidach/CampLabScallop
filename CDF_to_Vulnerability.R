#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#
#			Code to estimate vulnerability
#		
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#Author: Zach Siders
#Incept: 2020-Dec-12
###-----------------------------------------------------
#		Initialization
###-----------------------------------------------------
	#function to do the inverse logit
	inv_logit <- function(x){
		exp(x)/(exp(x)+1)
	}
	#function to do the logit
	logit <- function(x){
		log(x/(1-x))
	}
	#function to calculate the CDF
	cdfZS <- function(x, breaks){
	  x <- sort(x)
	  n <- length(x)
	  if(n < 1)
	    stop("'x' must have 1 or more non-missing values")
	  vals <- cut(x, seq(r.tl[1], r.tl[2], by = as.numeric(breaks)))
	  mids <- seq(r.tl[1], r.tl[2], by = as.numeric(breaks))[-length(seq(r.tl[1], r.tl[2], by = as.numeric(breaks)))] + (as.numeric(breaks)/2)
	  matches <- match(vals, levels(vals))
	  tab <- aggregate(matches,by=list(vals), length, drop=FALSE)$x
	  tab[is.na(tab)] <- 0
	  cum <- cumsum(tab)/n
	  raw <- as.data.frame(cbind(mids,cum))
	  raw <- raw[!duplicated(raw$cum),][-1,]
	  rval <- approxfun(raw$mids, raw$cum, 
	                    method = "constant", yleft = 0, yright = 1, f = 0, ties = "ordered")
	  class(rval) <- c("ecdf", "stepfun", class(rval))
	  assign("nobs", n, envir = environment(rval))
	  attr(rval, "call") <- sys.call()
	  rval
	  return(list("rval"=rval,"cum"=raw$cum,"vals"=raw$mids))
	}
###-----------------------------------------------------
#		Data Simulation
###-----------------------------------------------------
	#this simulates some lengths
	#replace with data
	sim.len <- rlnorm(100, log(65), 0.1)
	r.tl <- range(sim.len)
###-----------------------------------------------------
#		Fit CDF
###-----------------------------------------------------
	cdf.dat <- cdfZS(sim.len, 1)
###-----------------------------------------------------
#		GLM
###-----------------------------------------------------
	#grab the parts from the CDF fit that we need
	cdf.df <- data.frame(cum = cdf.dat$cum, 
	                     vals = cdf.dat$vals)

	mod.fit <- glm(cum ~ vals, data=cdf.df, family=binomial(link='logit'))
###-----------------------------------------------------
#		Output
###-----------------------------------------------------
	#determine L50 and sigma
	(l50 <- (logit(0.5) - coef(mod.fit)[1])/coef(mod.fit)[2])
	(sigma <- 1/coef(mod.fit)[2]) #determine the classic sigma

	std.pred <- 1/(1+exp(-(cdf.dat$val-l50)/sigma)) #regular logistic vulnerability model
###-----------------------------------------------------
#		Figures
###-----------------------------------------------------
	plot(cdf.dat$val,inv_logit(predict(mod.fit)), 
	     type='l', xlab='Shell Height', ylab="Vulnerability", las=1, lwd=3)
	points(cdf.dat$val, cdf.dat$cum)
	lines(cdf.dat$val, std.pred, col='red', lty=2)
	legend('topleft', legend=c("Data","Fit"), 
	       pch=c(1,NA), lty=c(NA,1), bty='n')